_15 Automated Testing and Cloud Deployment

Sprint 15: Automated Testing and Cloud Deployment
Intro
In the quiet of the lab, Terry reflects, knowing the work so far has been solid and meticulous. Now, itâ€™s time to add the tools that will help the lab run self-checks and prepare to share their creations with the world. This sprint is about validation and distributionâ€”ensuring quality and showcasing results.
Welcome to the final sprint! Here, you'll master skills that bring your project to life in a production environment, preparing it for real-world users.

Focus Areas
Automated Testing:
Learn to test your code automatically to prevent bugs and ensure reliability. Testing is a cornerstone of professional software engineering, enabling developers to confidently release their projects.
Write and run automated test suites.
Understand unit, integration, and end-to-end testing.
Use frameworks like Jest, Mocha, or Jasmine to streamline your testing process.
Cloud Deployment:
Deploy your project on a remote server, making it accessible to users anywhere. Youâ€™ll also enhance security and establish trust through data encryption.
Set up and configure a remote server.
Acquire and integrate a custom domain name.
Issue and link an SSL certificate for secure connections.
Deploy your application using Google Cloudâ€™s Virtual App Engine.

Skills Youâ€™ll Obtain
Creating and managing a custom domain for your application.
Securing your application with SSL certificates and encryption.
Deploying applications to the cloud and understanding the fundamentals of cloud-based infrastructure.
Writing and implementing automated tests to ensure the quality and reliability of your code.
By the end of this sprint, you'll have the tools and knowledge to launch your project into the world, equipped with the confidence that it will perform reliably and securely. Who knows, this might be the first step toward founding your very own startup!
Letâ€™s make it happen! ðŸš€
Why Testing is Crucial
Software projects grow and evolve, with new engineers adding features or tweaking existing functionality. Without tests, these changes can unintentionally break previously working features. Hereâ€™s why automated testing is essential:
Prevent Regression: Tests ensure that existing functionality continues to work as you add new features or make changes.
Save Time and Money: Automated tests catch problems early, reducing the cost and effort required to fix them later.
Enhance Confidence: Tests allow developers to make changes with confidence, knowing theyâ€™ll be alerted to any issues.

A Case Study
Elliott and Maxâ€™s story highlights the challenges of maintaining a system without tests:
Elliott created a system and moved on, leaving behind working functionality but no tests.
A year later, Max updated the system but unknowingly broke existing features.
Fixing the system required Elliott and Max to spend weeks identifying and repairing issuesâ€”a preventable scenario if automated tests had been in place.
Tests serve as a safety net, enabling new engineers to identify problems quickly and efficiently.

Manual Testing vs. Automated Testing
Testing code manually for every scenario is time-consuming and impractical in large projects. Automated testing eliminates this burden by running the program against predefined scenarios to ensure it behaves as expected.

Common Testing Frameworks
Automated testing relies on tools called frameworks, which provide the structure and utilities to write, organize, and execute tests. Two popular frameworks are:
Jest: Known for its versatility, Jest allows testing both front-end and back-end applications.
Mocha: A flexible and widely-used testing framework, often paired with libraries like Chai for assertions.
In this sprint, weâ€™ll focus on Jest, as it is a robust choice for full-stack testing.

By integrating automated tests into your development workflow, you ensure your application is not only functional but also resilient, even as it evolves over time. Letâ€™s dive in and start writing tests that protect your hard work! ðŸš€
Testing Frameworks and Methods
Automated testing frameworks are like the kid in the metaphorical story tasked to test a kitchen light to diagnose a power issue. They serve to validate and check that systems (or "lights") work as expected, ensuring engineers can efficiently diagnose problems without guessing. Here's a breakdown:

Core Concepts
Definition: A testing framework is a set of libraries used to test your code automatically.
Purpose:
Verify expected outcomes after changes (e.g., server requests still function after a redesign).
Prevent regression by ensuring new features donâ€™t break existing functionality.
Serve as "quality control" for engineers.

How It Works
Tests are structured around if/then logic:
"If we pass specific inputs to a function, then we expect this result."
Frameworks like Jest provide tools to automate this validation process:
Compare actual results to expected outcomes.
Highlight errors for quick troubleshooting.

Setting Up Jest
Create Project:
bash
Copy code
mkdir jest-demo && cd jest-demo && npm init --yes


Install Jest:
bash
Copy code
npm install --save-dev jest


Configure Scripts: Add "test": "jest" to the "scripts" section of package.json.
Write Tests:
Use .test.js files alongside your code files for naming consistency.
Example of a test:
javascript
Copy code
const sayHello = require('./function.js');
test('Creates a greeting', () => {
  expect(sayHello('Lera', 'Jackson')).toBe('Hello, Lera Jackson!');
});


Run Tests:
bash
Copy code
npm run test



Key Testing Methods
Comparison Operators:
toBe(): Compares primitive values or object references.
toEqual(): Checks object/array equivalence, ignoring extra properties.
toStrictEqual(): Like toEqual() but stricter, requiring exact matches.
Truthiness and Definition:
toBeTruthy(), toBeFalsy(): Validates truthy or falsy outputs.
toBeUndefined(), toBeDefined(): Checks if a value is undefined or not.
Special Cases:
toBeNull(): Validates null values.
toMatch(): Checks string patterns using regular expressions.
toContain(): Ensures an array or string contains a specific value.
Mathematical Comparisons:
toBeGreaterThan(), toBeLessThan(): Validates numerical relationships.
toBeGreaterThanOrEqual(), toBeLessThanOrEqual(): Ensures inclusive comparisons.

Handling Test Results
Passing:
A green PASS indicates tests succeeded.
Failing:
Detailed error logs pinpoint what failed and why (e.g., mismatch between expected and received values).
Example failure output:
plaintext
Copy code
FAIL ./function.test.js
âœ• Creates a greeting
Expected: "Hello, Ms. Lera Jackson"
Received: "Hello, Mr. Lera Jackson"



Advantages of Automated Testing
Efficiency: Saves time compared to manual testing.
Scalability: Supports growing projects by catching errors during updates.
Documentation: Tests serve as live documentation for other engineers to understand functionality.
Reliability: Provides confidence in code behavior, even as new features are added.

Key Takeaways
Testing frameworks like Jest act as a safety net, ensuring robust and error-free applications.
Well-written tests make it clear how an application behaves and aid in collaboration across teams.
Automated testing is not for end-user documentation but for engineers to maintain high-quality software.
By integrating automated tests, projects become easier to manage, debug, and scaleâ€”ensuring your metaphorical "lights" stay on, no matter whoâ€™s checking. ðŸŒŸ
4o

Units and Test Methods: Summary and Key Takeaways
In this lesson, we expanded on the use of tests by emphasizing what to test and how to handle projects with multiple functions. By breaking our application into units, we ensure thorough and efficient testing.

Key Concepts
What is a Unit?
A unit is the smallest piece of code that can be tested in isolation.
Usually a single function or method.
Units are the building blocks of testable applications.
Which Functions Should Be Tested?
Ideally, all functions should be tested.
This includes both "top-level" and internal functions.
Top-level functions often rely on smaller units, so testing only the top-level function can obscure where errors occur.
Example: Password Validation
A program to validate passwords has the following units:
checkNumber(pass): Verifies if the password contains a number.
checkSymbol(pass): Checks for special characters.
checkPass(pass): Combines the checks to validate the password.

Writing Tests for Each Unit
To ensure reliability and ease of debugging, write separate tests for each function:
Test checkNumber:
javascript
Copy code
test('Check that the password contains a number', () => {
    expect(checkNumber('some_not_so_strong_pass')).toBe(false);
    expect(checkNumber('stronger_pass_123')).toBe(true);
});


Test checkSymbol:
javascript
Copy code
test('Check that the password contains a special character', () => {
    expect(checkSymbol('somePass')).toBe(false);
    expect(checkSymbol('another_pass')).toBe(true);
});


Test checkPass:
javascript
Copy code
test('Check password', () => {
    expect(checkPass('somePas$')).toBe(false);
    expect(checkPass('another_pass_123')).toBe(true);
});



Why Test All Units?
Granularity:
Testing smaller units (e.g., checkNumber or checkSymbol) provides specific feedback about whatâ€™s broken.
Testing only the combined checkPass function may obscure the root cause of errors.
Efficiency:
When a test fails, youâ€™ll instantly know which specific function is the culprit.

Steps to Practice
Install Jest locally (if not already installed).
Refer back to the previous instructions on setting up Jest.
Write tests for individual functions in your editor.
Use the npm run test command to execute the tests and verify their results.

Key Takeaways
Test every function in your code to ensure thorough coverage.
Smaller, isolated tests make it easier to diagnose and fix errors.
Testing only top-level functions can lead to inefficiency and confusion when debugging.
Good testing practices create a layer of protection for your application, making it robust, reliable, and maintainable.
By writing comprehensive tests for all units, you'll build an application that behaves predictably even as it scales or evolves. ðŸš€
Testing: Divisibility by 3
Objective
Write a function to check if a number is divisible by 3 and test it thoroughly using multiple inputs to ensure it behaves as expected.

Step 1: Write the Function
Create a simple function to check divisibility by 3:
javascript
Copy code
// isDivisibleByThree.js

function isDivisibleByThree(num) {
    return num % 3 === 0;
}

module.exports = isDivisibleByThree;


Step 2: Write Tests
Create a test file named isDivisibleByThree.test.js to test the function with various inputs:
javascript
Copy code
// isDivisibleByThree.test.js

const isDivisibleByThree = require('./isDivisibleByThree');

test('Check divisibility by 3', () => {
    // Test cases that should return true
    expect(isDivisibleByThree(3)).toBe(true);
    expect(isDivisibleByThree(9)).toBe(true);
    expect(isDivisibleByThree(0)).toBe(true); // edge case

    // Test cases that should return false
    expect(isDivisibleByThree(4)).toBe(false);
    expect(isDivisibleByThree(10)).toBe(false);
    expect(isDivisibleByThree(-5)).toBe(false); // negative number case
});


Step 3: Run Tests
Execute the tests using Jest:
bash
Copy code
npm run test


Expected Output
If everything is correct, you should see:
plaintext
Copy code
PASS  ./isDivisibleByThree.test.js
âœ“ Check divisibility by 3 (3ms)

Test Suites: 1 passed, 1 total
Tests:       1 passed, 1 total
Snapshots:   0 total
Time:        1.123s
Ran all test suites.


Key Considerations
True Cases: Include multiple values divisible by 3 (e.g., 3, 9, 0).
False Cases: Test numbers that are not divisible by 3 (e.g., 4, 10, -5).
Edge Cases: Test for edge cases like 0 (should return true) and negative numbers.

By following these steps, you ensure that your function is reliable and behaves as expected across a variety of inputs. ðŸŽ‰
Testing: URL Generator Function
Hereâ€™s how to write and test a function that generates URL strings, ensuring the output is a string and matches the provided urlRegEx regular expression.

Step 1: Define the Regular Expression
The regular expression to validate URLs:
javascript
Copy code
const urlRegEx = /^(https?:\/\/)?([a-z0-9]+[.])+[a-z]{2,6}(:[0-9]{1,5})?(\/.*)?$/i;


Step 2: Write the Function
A simple function to generate a URL string:
javascript
Copy code
// generateUrl.js

function generateUrl(base, path) {
    if (typeof base !== 'string' || typeof path !== 'string') {
        throw new Error('Invalid input: base and path must be strings');
    }
    const sanitizedBase = base.endsWith('/') ? base.slice(0, -1) : base;
    const sanitizedPath = path.startsWith('/') ? path.slice(1) : path;
    return `${sanitizedBase}/${sanitizedPath}`;
}

module.exports = generateUrl;


Step 3: Write Tests
Create a test file generateUrl.test.js to validate the function:
javascript
Copy code
// generateUrl.test.js

const generateUrl = require('./generateUrl');

// Regular expression for validating URLs
const urlRegEx = /^(https?:\/\/)?([a-z0-9]+[.])+[a-z]{2,6}(:[0-9]{1,5})?(\/.*)?$/i;

test('Returns a string and matches the URL format', () => {
    const base = 'https://example.com';
    const path = '/api/resource';
    const result = generateUrl(base, path);

    // Check that the result is a string
    expect(typeof result).toBe('string');

    // Check that the string matches the URL regular expression
    expect(result).toMatch(urlRegEx);
});

test('Handles trailing slashes correctly', () => {
    expect(generateUrl('https://example.com/', '/resource')).toBe('https://example.com/resource');
    expect(generateUrl('https://example.com', 'resource')).toBe('https://example.com/resource');
});

test('Throws an error for invalid inputs', () => {
    expect(() => generateUrl(123, '/path')).toThrow('Invalid input: base and path must be strings');
    expect(() => generateUrl('https://example.com', null)).toThrow('Invalid input: base and path must be strings');
});


Step 4: Run Tests
Execute the tests using Jest:
bash
Copy code
npm run test


Expected Output
When all tests pass, youâ€™ll see:
plaintext
Copy code
PASS  ./generateUrl.test.js
âœ“ Returns a string and matches the URL format (3ms)
âœ“ Handles trailing slashes correctly (2ms)
âœ“ Throws an error for invalid inputs (1ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.456s
Ran all test suites.


Key Points
Use toMatch() to check if the string matches the urlRegEx.
Validate both correct and incorrect inputs.
Handle edge cases like trailing slashes in the base URL or path.
Ensure meaningful errors for invalid inputs.
This approach ensures your URL generator function is both accurate and reliable. ðŸš€
Test Suites: Organizing Tests Effectively
Overview
Tests are vital for ensuring code reliability, but when working on larger applications, organizing tests into test suites is equally important. A test suite groups related unit tests, making your tests easier to manage, modify, and understand.

Why Use Test Suites?
Improved Organization: Groups tests related to the same feature or function.
Readability: Provides clear context about what is being tested.
Ease of Maintenance: Simplifies updates and debugging in complex systems.
Better Reporting: Adds descriptive labels in test results, making it easier to locate issues.

Creating a Test Suite
The describe() function is used to define a test suite. It accepts:
Suite Name: A descriptive name for the group of tests.
Callback Function: Contains the individual tests within the suite.
Example: Testing a User Registration Handler
javascript
Copy code
describe('Request handler tests', () => {
  test('should validate the data', () => {
    // Test data validation logic
  });

  test('should calculate the password hash', () => {
    // Test password hash generation logic
  });

  test('should write the data to the database', () => {
    // Test database write logic
  });
});


Example Test Output
When the test suite runs, it produces a detailed and organized report:
plaintext
Copy code
PASS  ./api.test.js
Request handler tests
âœ“ should validate the data (3ms)
âœ“ should calculate the password hash (5ms)
âœ“ should write the data to the database (7ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.747s
Ran all test suites.


Key Benefits
Hierarchy: Grouping related tests under a suite name provides a natural structure.
Contextual Reporting: Clearly indicates what functionality was tested (e.g., "Request handler tests").
Scalability: Allows for easy extension by adding new tests to existing suites.

Best Practices for Test Suites
Group Tests Logically:
By feature (e.g., user authentication, payment processing).
By function (e.g., data validation, database operations).
Use Clear Descriptions:
Provide meaningful names for test suites and individual tests to improve readability.
Avoid Overlapping Suites:
Ensure test suites focus on distinct functionalities to avoid redundancy.

Key Takeaways
Test suites (describe()) allow logical grouping of related unit tests.
They improve the organization, readability, and maintainability of your test code.
Suite names provide contextual clarity in test results, making debugging more straightforward.
Properly organized test suites save time and effort in the long run.
By incorporating test suites into your workflow, you create a well-structured, scalable, and efficient testing process. ðŸš€
Test Suites Practice: Testing validateUserInput
Hereâ€™s how you can structure your tests for the validateUserInput function and its helper functions isValidEmail and isValidPassword.

Setup the Context
The validateUserInput Function
Inputs:
An object with email and password.
Outputs:
An object with properties:
isValidated (boolean): true if both email and password are valid, otherwise false.
message (string or null): 'User created successfully' if valid, otherwise null.
error (string or null): Specific error messages if validation fails.
Test Data
Use these objects as test cases:
javascript
Copy code
const dataValid = { email: 'valid@example.com', password: 'StrongPass123!' };
const dataInvalidPassword = { email: 'valid@example.com', password: 'weak' };
const dataInvalidEmail = { email: 'invalid-email', password: 'StrongPass123!' };
const dataInvalidCredentials = { email: 'invalid-email', password: 'weak' };


Test Suite
Write a test suite using describe to group all related tests for validateUserInput:
Tests
Validate the isValidEmail function:
Should return true for valid emails.
Should return false for invalid emails.
Validate the isValidPassword function:
Should return true for valid passwords.
Should return false for invalid passwords.
Validate the validateUserInput function:
Should return success when data is valid.
Should return specific error messages when validation fails.

Implementation
Hereâ€™s the test suite code:
javascript
Copy code
// validateUserInput.test.js
const { isValidEmail, isValidPassword, validateUserInput } = require('./validateUserInput');

describe('User Input Validation Tests', () => {
    // Test data
    const dataValid = { email: 'valid@example.com', password: 'StrongPass123!' };
    const dataInvalidPassword = { email: 'valid@example.com', password: 'weak' };
    const dataInvalidEmail = { email: 'invalid-email', password: 'StrongPass123!' };
    const dataInvalidCredentials = { email: 'invalid-email', password: 'weak' };

    // #1 isValidEmail Tests
    test('isValidEmail should validate correct emails', () => {
        expect(isValidEmail('valid@example.com')).toBe(true);
        expect(isValidEmail('invalid-email')).toBe(false);
    });

    // #2 isValidPassword Tests
    test('isValidPassword should validate correct passwords', () => {
        expect(isValidPassword('StrongPass123!')).toBe(true);
        expect(isValidPassword('weak')).toBe(false);
    });

    // #3 validateUserInput Tests
    test('validateUserInput should return success message when data is valid', () => {
        const result = validateUserInput(dataValid);
        expect(result.isValidated).toBe(true);
        expect(result.message).toBe('User created successfully');
        expect(result.error).toBeNull();
    });

    test('validateUserInput should return email error when email is invalid', () => {
        const result = validateUserInput(dataInvalidEmail);
        expect(result.isValidated).toBe(false);
        expect(result.message).toBeNull();
        expect(result.error).toBe('Wrong email');
    });

    test('validateUserInput should return password error when password is invalid', () => {
        const result = validateUserInput(dataInvalidPassword);
        expect(result.isValidated).toBe(false);
        expect(result.message).toBeNull();
        expect(result.error).toBe('Wrong password');
    });

    test('validateUserInput should return incorrect data error when all data is invalid', () => {
        const result = validateUserInput(dataInvalidCredentials);
        expect(result.isValidated).toBe(false);
        expect(result.message).toBeNull();
        expect(result.error).toBe('Incorrect data');
    });
});


Run the Tests
Run the tests using Jest:
bash
Copy code
npm run test


Expected Output
plaintext
Copy code
PASS  ./validateUserInput.test.js
User Input Validation Tests
âœ“ isValidEmail should validate correct emails (3ms)
âœ“ isValidPassword should validate correct passwords (2ms)
âœ“ validateUserInput should return success message when data is valid (4ms)
âœ“ validateUserInput should return email error when email is invalid (2ms)
âœ“ validateUserInput should return password error when password is invalid (1ms)
âœ“ validateUserInput should return incorrect data error when all data is invalid (1ms)

Test Suites: 1 passed, 1 total
Tests:       6 passed, 6 total
Snapshots:   0 total
Time:        1.745s
Ran all test suites.


Key Takeaways
Test individual helper functions (isValidEmail, isValidPassword) separately.
Ensure validateUserInput handles all scenarios, including valid, partially invalid, and completely invalid inputs.
Use meaningful test data and assertions to verify expected outcomes.
Group all tests into a descriptive test suite for better organization and readability.
This approach ensures comprehensive validation coverage for the validateUserInput function. ðŸš€
Testing HTTP Requests: Practice
Objective
Write tests for an HTTP server application to validate responses for different endpoints. Specifically:
A GET request to / should return a string and correct status code.
A POST request to /users should return a JSON object, appropriate status code, and specific response details.

Setup
Install Dependencies:
bash
Copy code
npm install


Understand the Endpoints:
GET /:
Response body: 'Hello, world!'
Response status: 200 OK
POST /users:
Returns a JSON object with user data.
Response status: 201 Created.
Response header: Content-Type: application/json.

Tests to Write
GET /
Validate that the response:
Has a status code of 200.
Returns the string 'Hello, world!'.
POST /users
Validate that the response:
Has a status code of 201.
Has the header Content-Type: application/json.
Contains the expected data fields in the response body.
Extra Validations:
Confirm that:
The response body includes a "message" containing the text "success".
The isDeveloper field in response.body.data is true.
The followersOnGithub field in response.body.data is greater than 10.

Implementation
Hereâ€™s the test suite for the server:
javascript
Copy code
const request = require('supertest'); // Assuming supertest is used for HTTP testing
const app = require('./app'); // Assuming the Express app is exported from app.js

describe('HTTP Request Tests', () => {
    // Test GET /
    test('GET / should return "Hello, world!" with status 200', async () => {
        const response = await request(app).get('/');
        expect(response.status).toBe(200);
        expect(response.text).toBe('Hello, world!');
    });

    // Test POST /users
    test('POST /users should return user data with status 201', async () => {
        const userData = { name: 'John Doe', isDeveloper: true, followersOnGithub: 20 };

        const response = await request(app)
            .post('/users')
            .send(userData)
            .set('Content-Type', 'application/json');

        // Check status and content type
        expect(response.status).toBe(201);
        expect(response.headers['content-type']).toMatch(/application\/json/);

        // Check response body
        expect(response.body).toHaveProperty('message', 'User created successfully');
        expect(response.body.data).toMatchObject(userData);
    });

    // Extra Validations
    test('POST /users should contain additional response validations', async () => {
        const userData = { name: 'Jane Doe', isDeveloper: true, followersOnGithub: 25 };

        const response = await request(app)
            .post('/users')
            .send(userData)
            .set('Content-Type', 'application/json');

        // Validate specific response fields
        expect(response.body.message).toContain('success');
        expect(response.body.data.isDeveloper).toBe(true);
        expect(response.body.data.followersOnGithub).toBeGreaterThan(10);
    });
});


Run the Tests
Execute the tests:
bash
Copy code
npm run test


Expected Output
plaintext
Copy code
PASS  ./httpRequests.test.js
HTTP Request Tests
âœ“ GET / should return "Hello, world!" with status 200 (15ms)
âœ“ POST /users should return user data with status 201 (10ms)
âœ“ POST /users should contain additional response validations (5ms)

Test Suites: 1 passed, 1 total
Tests:       3 passed, 3 total
Snapshots:   0 total
Time:        1.467s
Ran all test suites.


Key Takeaways
Basic Validations:
Ensure correct response status, headers, and body content for each endpoint.
Advanced Validations:
Test specific fields or conditions in the response for deeper validation.
Structured Suites:
Use descriptive test suite names and organize related tests logically.
Testing Tools:
Use supertest or equivalent tools to simplify HTTP request testing.
By writing these comprehensive tests, you ensure that your HTTP endpoints work as intended and handle both expected and edge cases effectively. ðŸš€
Database Testing
Testing interactions with a database requires a systematic approach to ensure user data isn't compromised. The process involves using temporary test data that is added, tested, and then removed to maintain database integrity.

Why Test Databases?
Verify database interactions (e.g., queries, inserts, updates, deletions).
Ensure application logic integrates correctly with the database.
Detect and prevent issues without risking real user data.

Key Principles
Use Test Data:
Use random, meaningless data during tests.
Clean up the data after each test to avoid clutter and interference.
Test Lifecycle Hooks:
beforeAll(): Runs once before all tests, often used to set up a connection or initial state.
afterAll(): Runs once after all tests, typically to close connections or perform final cleanup.
beforeEach(): Runs before every test, useful for adding test-specific data.
afterEach(): Runs after every test, used for removing test-specific data.

Testing Structure
Hereâ€™s how to organize your database tests:
Global Setup and Teardown:
Use beforeAll() and afterAll() outside of test suites to manage the database connection lifecycle.
Suite-Level Setup and Cleanup:
Use beforeAll() and afterAll() inside a describe() block to handle data specific to that test suite.
Test-Specific Setup and Cleanup:
Use beforeEach() and afterEach() for adding and cleaning up test-specific data.

Implementation Example
Database Connection Functions
javascript
Copy code
const db = require('./db'); // Mock database module

async function connectToDb() {
    await db.connect();
}

async function disconnectFromDb() {
    await db.disconnect();
}

async function addTestData(data) {
    await db.insert(data);
}

async function removeTestData(filter) {
    await db.delete(filter);
}

Test File
javascript
Copy code
describe('Database Tests', () => {
    const testData = { id: 1, name: 'Test User', email: 'test@example.com' };

    beforeAll(async () => {
        // Establish database connection
        await connectToDb();
    });

    afterAll(async () => {
        // Close database connection
        await disconnectFromDb();
    });

    beforeEach(async () => {
        // Add test data before each test
        await addTestData(testData);
    });

    afterEach(async () => {
        // Remove test data after each test
        await removeTestData({ id: testData.id });
    });

    test('should retrieve the test data', async () => {
        const result = await db.find({ id: testData.id });
        expect(result).toMatchObject(testData);
    });

    test('should update the test data', async () => {
        const updatedData = { name: 'Updated User' };
        await db.update({ id: testData.id }, updatedData);

        const result = await db.find({ id: testData.id });
        expect(result.name).toBe('Updated User');
    });
});

Test Output
When running the tests:
plaintext
Copy code
PASS  ./database.test.js
Database Tests
âœ“ should retrieve the test data (30ms)
âœ“ should update the test data (25ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.537s
Ran all test suites.


Best Practices
Isolation: Each test should be independent; one testâ€™s data should not affect another.
Data Cleanup: Always remove test data to keep the database clean.
Performance: Use beforeAll() and afterAll() for one-time setup to save time, and beforeEach()/afterEach() only for test-specific needs.
Mocks and Stubs: Consider mocking database interactions for faster and more controlled tests.

Key Takeaways
Lifecycle Hooks: Use beforeAll, afterAll, beforeEach, and afterEach strategically to manage test data and connections.
Temporary Data: Add test data before tests and clean it up afterward.
Organized Suites: Group related database tests using describe() for clarity and maintainability.
This approach ensures your database tests are safe, efficient, and effective, allowing you to verify functionality without compromising real user data. ðŸš€

Practice
This practice involves testing database interactions using Mongoose, adhering to a systematic testing lifecycle to ensure the database remains clean and reusable for multiple test runs.

Objective
Setup Lifecycle Hooks:
Connect to the database before running tests.
Add test data before each test.
Remove test data after each test.
Disconnect from the database after all tests are complete.
Test User Data:
Verify that a user document is present in the database.
Check that the document has the correct data.

Setup and Implementation
Database Test File
javascript
Copy code
const mongoose = require('mongoose');
const User = require('./models/User'); // Assuming the user model is defined in models/User.js
const fixtures = require('./fixtures/fixtures'); // Test data

describe('Database Testing', () => {
    // Connect to the database before all tests
    beforeAll(async () => {
        const dbUrl = 'mongodb://localhost:27017/testdb'; // Replace with your database URL
        const dbOptions = {
            useNewUrlParser: true,
            useUnifiedTopology: true,
        };
        await mongoose.connect(dbUrl, dbOptions);
    });

    // Disconnect from the database after all tests
    afterAll(async () => {
        await mongoose.connection.db.dropDatabase(); // Optional: Clean the entire test database
        await mongoose.disconnect();
    });

    // Add test data before each test
    beforeEach(async () => {
        await User.create(fixtures.user);
    });

    // Remove test data after each test
    afterEach(async () => {
        await User.deleteOne({ email: fixtures.user.email });
    });

    // Test case: Verify user data
    test('The user must be complete', async () => {
        const user = await User.findOne({ email: fixtures.user.email });

        expect(user).toBeDefined();
        expect(user.email).toBe(fixtures.user.email);
        expect(user.name).toBe(fixtures.user.name);
    });

    // Additional Test Case: Verify user data is not found after deletion
    test('User data should be removed after test', async () => {
        await User.deleteOne({ email: fixtures.user.email });
        const user = await User.findOne({ email: fixtures.user.email });
        expect(user).toBeNull();
    });
});


Lifecycle Breakdown
beforeAll:
Establishes a connection to the test database.
Ensures the database is ready for operations.
afterAll:
Cleans up the database (optional: drops it entirely for full reset).
Disconnects from the database.
beforeEach:
Inserts test data (e.g., a user document) into the database before each test.
afterEach:
Removes test data (e.g., the user document) after each test to prevent data overlap.

Running the Tests
Use the following command to run the tests:
bash
Copy code
npm run test


Expected Output
If the tests are written and implemented correctly, the output should look like this:
plaintext
Copy code
PASS  ./database.test.js
Database Testing
âœ“ The user must be complete (45ms)
âœ“ User data should be removed after test (30ms)

Test Suites: 1 passed, 1 total
Tests:       2 passed, 2 total
Snapshots:   0 total
Time:        1.587s
Ran all test suites.


Key Takeaways
Safe Testing: Use isolated test data and clean it up after each test to avoid affecting real data.
Lifecycle Management: Use beforeAll, afterAll, beforeEach, and afterEach hooks to manage database connections and data efficiently.
Reusability: Ensure tests can run multiple times without manual intervention or leftover data.
By following this structured approach, you create reliable and repeatable tests for your database interactions. ðŸš€

Automated Testing: Comprehensive Conclusion
In this module, you've delved into the essentials of automated testing, a critical component in software development that ensures code reliability, maintainability, and scalability. Here's a comprehensive wrap-up of what you've learned:

Key Learnings
Understanding Automated Testing:
Purpose: Automated tests validate that your code works as expected, catching bugs early in the development process.
Benefits: Saves time, prevents regressions, and serves as documentation for your code's functionality.
Testing Frameworks:
Definition: Libraries and tools that provide a structured way to write and run tests.
Jest: A popular testing framework that supports both front-end and back-end JavaScript applications.
Setting Up Jest:
Installation:
bash
Copy code
npm install --save-dev jest


Configuration: Add "test": "jest" to the "scripts" section of your package.json file.
Writing Tests:
Test Files: Name test files with .test.js or .spec.js extensions.
Test Structure:
javascript
Copy code
test('description of test', () => {
  // test code here
});


Assertions: Use expect() along with matcher methods to define expected outcomes.
Common Testing Methods:
Primitive and Reference Comparison: toBe()
Object and Array Comparison: toEqual(), toStrictEqual()
Truthiness: toBeTruthy(), toBeFalsy()
Defined and Undefined: toBeDefined(), toBeUndefined()
Null Checks: toBeNull()
String Matching: toMatch()
Containment: toContain()
Numerical Comparisons: toBeGreaterThan(), toBeLessThan(), etc.
Organizing Tests with Test Suites:
Grouping Tests: Use describe() to group related tests for better organization and readability.
Example:
javascript
Copy code
describe('Feature or Component', () => {
  test('should perform a specific function', () => {
    // test code
  });
});


Testing Units:
Unit Testing: Focus on testing individual units (functions or methods) in isolation.
Practice: Write tests for all units to quickly identify where issues occur.
Testing HTTP Requests:
API Testing: Use tools like supertest to simulate HTTP requests and validate responses.
Status Codes and Headers: Check for correct status codes and response headers.
Database Testing:
Safe Testing Practices:
Use test databases or mock data.
Clean up test data after tests run.
Lifecycle Methods: Utilize beforeAll(), afterAll(), beforeEach(), and afterEach() to manage database connections and data setup/teardown.

Table of Common Jest Testing Methods
Below is a table summarizing the most commonly used Jest matcher methods:
Method
Purpose
Example
toBe(value)
Checks if the received value is exactly equal (===) to value.
expect(2 + 2).toBe(4);
toEqual(value)
Checks if the received value matches value recursively.
expect(obj1).toEqual(obj2);
toStrictEqual(value)
Like toEqual(), but also checks object types and undefined properties.
expect(obj1).toStrictEqual(obj2);
toBeTruthy()
Checks if the received value is truthy.
expect('hello').toBeTruthy();
toBeFalsy()
Checks if the received value is falsy.
expect(0).toBeFalsy();
toBeNull()
Checks if the received value is null.
expect(null).toBeNull();
toBeUndefined()
Checks if the received value is undefined.
expect(undefined).toBeUndefined();
toBeDefined()
Checks if the received value is not undefined.
expect(value).toBeDefined();
toMatch(regexOrString)
Checks if a string matches a regular expression or string.
expect('abc').toMatch(/a.c/);
toContain(item)
Checks if an array or iterable contains item.
expect([1, 2, 3]).toContain(2);
toBeGreaterThan(number)
Checks if the received value is greater than number.
expect(10).toBeGreaterThan(5);
toBeGreaterThanOrEqual(number)
Checks if the received value is greater than or equal to number.
expect(5).toBeGreaterThanOrEqual(5);
toBeLessThan(number)
Checks if the received value is less than number.
expect(3).toBeLessThan(5);
toBeLessThanOrEqual(number)
Checks if the received value is less than or equal to number.
expect(5).toBeLessThanOrEqual(5);
toThrow(error?)
Checks if a function throws an error when called.
expect(() => func()).toThrow(Error);
toHaveLength(number)
Checks if an object has a .length property equal to number.
expect([1, 2, 3]).toHaveLength(3);
toHaveProperty(keyPath, value?)
Checks if an object has a property at keyPath, optionally with a specific value.
expect(obj).toHaveProperty('name', 'John');
toBeInstanceOf(Class)
Checks if the received value is an instance of Class.
expect(new Error()).toBeInstanceOf(Error);


Final Thoughts
Thorough Testing: Writing tests for every unit may seem time-consuming, but it is invaluable for maintaining code quality, especially as projects grow in complexity.
Test as Documentation: Tests serve as live documentation, providing clear examples of how functions are intended to work.
Applicability: While you've practiced with Jest, these concepts are transferable to other testing frameworks like Mocha, Jasmine, or AVA.

Next Steps
As you move forward to the final chapter of this program, you'll apply these testing skills to prepare and deploy your back end:
Deployment Preparation: Learn how to ready your application for production environments.
Cloud Deployment: Explore deploying your back end to cloud services, ensuring it's accessible and scalable.

By mastering automated testing, you've added a crucial tool to your developer toolkit, enabling you to create reliable and robust applications. Keep practicing, and embrace testing as an integral part of your development process. ðŸš€

Advanced Middleware

Intro to Advanced Middleware
In this chapter, youâ€™ll enhance the WTWR (What To Wear) application by implementing advanced middleware techniques to improve its stability, usability, and maintainability. Middleware serves as the backbone of server-side applications, intercepting and processing requests and responses to perform various tasks such as error handling, data validation, and logging.

Why Advanced Middleware Matters
Middleware allows you to:
Validate Data: Ensure user input meets specific criteria before processing.
Handle Errors Gracefully: Centralized error handling makes debugging easier and keeps your application stable.
Log Requests and Errors: Track user activity and application issues for better monitoring and maintenance.

Garden Metaphor
Think of your application as a growing garden. Every new visitor (user) brings seeds (data) that need careful inspection:
Data Validation: Ensures seeds are healthy (valid data).
Error Handling: Deals with bad seeds or unexpected issues without disrupting the gardenâ€™s harmony.
Logging: Tracks which seeds were planted and if any caused problems, so the gardener (you) can adjust accordingly.

Objectives
By the end of this chapter, you will have implemented three types of middleware:
Centralized Error Handling:
Manage all errors in one place for cleaner code and easier debugging.
Ensure consistent error responses to the client.
Data Validation:
Verify that user input adheres to specified formats and constraints.
Protect your application from invalid or malicious data.
Request and Error Logging:
Track incoming requests and application errors.
Use logs to identify and fix issues or optimize the applicationâ€™s performance.

Implementation Goals
Throughout this chapter, youâ€™ll apply middleware directly to your WTWR project:
Follow Along: Keep your project open and apply the instructions as you progress through the material.
Incremental Changes: Implement middleware step by step, ensuring it integrates smoothly with your existing code.
Final Review: While thereâ€™s no immediate submission, aim for a complete, robust implementation by the end of the sprint.

Key Benefits of Middleware
Improved Stability: Centralized error handling ensures your application continues to operate even when issues arise.
Enhanced Security: Data validation protects against invalid inputs and malicious attacks.
Better Monitoring: Logging provides valuable insights into application usage and performance.

Letâ€™s dive in and take your application to the next level with advanced middleware! ðŸš€

Centralized Error Handling
Centralized error handling is a powerful approach for managing errors in your application. By funneling all errors into a single middleware, you avoid code duplication, ensure consistency in error responses, and make your application easier to maintain and debug.

How Centralized Error Handling Works
1. Traditional Error Handling
Previously, errors were handled directly in controllers or middleware, often leading to repetitive code:
javascript
Copy code
try {
  // logic
} catch (err) {
  console.error(err);
  res.status(400).send({ message: 'Error message' });
}


2. Centralized Approach
Use a dedicated middleware at the end of your middleware stack:
javascript
Copy code
app.use((err, req, res, next) => {
  console.error(err);
  res.status(500).send({ message: 'An error occurred on the server' });
});


Errors are forwarded to this handler using next(err).

Best Practices
Use next() with an Error Argument
Errors are passed to the error handler using:
javascript
Copy code
next(new Error('Custom error message'));


Custom Error Classes
Create custom error constructors for common errors:
javascript
Copy code
class NotFoundError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = 404;
  }
}
module.exports = NotFoundError;


Use these in your controllers:
javascript
Copy code
if (!user) {
  throw new NotFoundError('User not found');
}


Catch Block for Errors
End promise chains with .catch(next):
javascript
Copy code
User.findOne({ _id: req.params.id })
  .then(user => {
    if (!user) throw new NotFoundError('User not found');
    res.send(user);
  })
  .catch(next);


Handle Known Errors
Check for specific error types (e.g., CastError):
javascript
Copy code
.catch(err => {
  if (err.name === 'CastError') {
    next(new BadRequestError('Invalid ID format'));
  } else {
    next(err);
  }
});


Catch-All for Unknown Errors
Ensure the handler accounts for unknown errors:
javascript
Copy code
app.use((err, req, res, next) => {
  const { statusCode = 500, message } = err;
  res.status(statusCode).send({
    message: statusCode === 500 ? 'An error occurred on the server' : message,
  });
});



Rules for Centralized Error Handling
Rule
Description
Log Errors
Use console.error(err) to log errors for debugging.
Terminate Promise Chains
Always use a .catch() block to handle errors in promise chains.
Avoid throw in Terminal Catch Blocks
Redirect errors with next(err) instead of throw.
Default to 500 for Unknown Errors
If an error lacks a status code, assign a 500 status and a generic message.


Key Benefits
Consistency: Centralized error handling ensures uniform error messages and status codes.
Maintainability: Changes to error response formatting only need to be made in one place.
Debugging: Logging all errors in a single location simplifies tracking down issues.

Next Steps
Add error-handling middleware to your WTWR application.
Implement custom error constructors and update your controllers to use them.
Ensure your app gracefully handles known and unknown errors.
With centralized error handling, your application will become more stable, easier to debug, and ready for scalable development. ðŸš€
